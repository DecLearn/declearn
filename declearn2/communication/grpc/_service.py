# coding: utf-8

"""gRPC MessageBoard Service implementing messages passing.

The `Service` class implemented here is a grpc MessageBoard designed
to handle messages transmitted over gRPC using the models defined in
a protobuf file (and derived python tools auto-generated by the grpc
compiler).
"""

import json
import time
from concurrent import futures
from typing import Any, Dict, Optional

import grpc  # type: ignore

from declearn2.communication.api import flags
from declearn2.communication.grpc.protobufs.message_pb2 import (
    CheckMessageRequest, Empty, Error, JoinRequest, JoinReply, Message
)
from declearn2.communication.grpc.protobufs.message_pb2_grpc import (
    MessageBoardServicer, add_MessageBoardServicer_to_server
)
from declearn2.utils import json_unpack


class Service(MessageBoardServicer):
    """A gRPC MessageBoard service to be used by GrpcServer instances."""

    def __init__(
            self,
            nb_clients: int,
            host: str = 'localhost',
            port: int = 0,
            credentials: Optional[grpc.ChannelCredentials] = None,
        ) -> None:
        """Instantiate the gRPC service."""
        self.nb_clients = nb_clients
        self.host = host
        self.port = port
        # Set up a grpc Server based on the previous attributes.
        self.server = self._setup_server(credentials)
        # Set up clients and incoming / outgoing messages registries.
        self.registered_users = {}  # type: Dict[str, Dict[str, Any]]
        self.outgoing_messages = {}  # type: Dict[str, Dict[str, Any]]
        self.incoming_messages = {}  # type: Dict[str, Dict[str, Any]]

    def _setup_server(
            self,
            credentials: Optional[grpc.ChannelCredentials],
        ) -> grpc.Server:
        """Set up and return a grpc Server to be used by this service."""
        server = grpc.aio.server(futures.ThreadPoolExecutor(max_workers=10))
        add_MessageBoardServicer_to_server(self, server)  # type: ignore
        address = f'{self.host}:{self.port}'
        self.port = (
            server.add_secure_port(address, credentials)
            if (credentials is not None)
            else server.add_insecure_port(address)
        )
        return server

    async def start(
            self,
        ) -> None:
        """Start the grpc.Server wrapped by this service."""
        await self.server.start()

    async def stop(
            self,
        ) -> None:
        """Stop the grpc.Server wrapped by this service."""
        await self.server.stop(grace=None)

    def ping(
            self,
            request: Empty,
            context: grpc.ServicerContext,
        ) -> Empty:
        """Handle a ping request."""
        if context.peer() not in self.registered_users:
            return Error(message=flags.FLAG_REFUSE_CONNECTION)
        return Empty()

    def join(
            self,
            request: JoinRequest,
            context: grpc.ServicerContext,
        ) -> JoinReply:
        """Handle a join request."""
        if context.peer() in self.registered_users:
            return JoinReply(message=flags.FLAG_REFUSE_CONNECTION)
        # If clients are still welcome, register the user and welcome it.
        if len(self.registered_users) < self.nb_clients:
            self._register_user(request, context)
            return JoinReply(flag=flags.FLAG_WELCOME)
        # Otherwise, return a negative JoinReply.
        return JoinReply(flag=flags.FLAG_REFUSE_CONNECTION)

    def _register_user(
            self,
            request: JoinRequest,
            context: grpc.ServicerContext,
        ) -> None:
        """Register a user based on its JoinRequest and ServicerContext."""
        # Deserialize the received information.
        name = request.name  # type: str
        info = json.loads(request.info, object_hook=json_unpack)
        # Generate a user alias (ensuring clients' names are not duplicated).
        alias = name
        aliases = {info["alias"] for info in self.registered_users.values()}
        if name in aliases:
            idx = sum(other.rsplit('.', 1)[0] == name for other in aliases)
            alias = f"{name}.{idx}"
        # Record the user's information, including its alias name.
        info = {"name": request.name, "alias": alias, "data_info": info}
        self.registered_users[context.peer()] = info

    def check_message(
            self,
            request: CheckMessageRequest,
            context: grpc.ServicerContext,
        ) -> Message:
        """Handle a Message-checking request from a client."""
        if context.peer() not in self.registered_users:
            return Error(message=flags.FLAG_REFUSE_CONNECTION)
        name = self.registered_users[context.peer()]["alias"]
        # Stay idle until at least one message is available.
        while not self.outgoing_messages.get(name):
            time.sleep(1)
        # Unstack the oldest available message and return it.
        message = self.outgoing_messages.pop(name)
        return Message(action=message['action'], params=message['params'])

    def send_message(
            self,
            request: Message,
            context: grpc.ServicerContext,
        ) -> Empty:
        """Handle a Message-sending request from a client."""
        if context.peer() not in self.registered_users:
            return Error(message=flags.FLAG_REFUSE_CONNECTION)
        name = self.registered_users[context.peer()]["alias"]
        # Deserialize the message's content and make it available.
        message = json.loads(request.params, object_hook=json_unpack)
        self.incoming_messages[name] = message
        # Ping back the message sender.
        return Empty()
